<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ring-Puzzle-Solver &mdash; Erkl&auml;rung &amp; Quellcode</title>
<style>
  :root {
    --bg: #0d1117;
    --surface: #161b22;
    --border: #30363d;
    --text: #e6edf3;
    --muted: #8b949e;
    --accent: #58a6ff;
    --green: #3fb950;
    --red: #f85149;
    --yellow: #d29922;
    --purple: #bc8cff;
    --ring-bg: #1c2333;
    --code-bg: #0d1117;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    background: var(--bg);
    color: var(--text);
    line-height: 1.7;
    padding: 2rem;
    max-width: 960px;
    margin: 0 auto;
  }

  h1 {
    font-size: 2rem;
    font-weight: 700;
    margin-bottom: 0.25rem;
    background: linear-gradient(135deg, var(--accent), var(--purple));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  .subtitle {
    color: var(--muted);
    font-size: 0.95rem;
    margin-bottom: 2.5rem;
    border-bottom: 1px solid var(--border);
    padding-bottom: 1.5rem;
  }

  h2 {
    font-size: 1.35rem;
    margin: 2.5rem 0 1rem;
    color: var(--accent);
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  h2 .num {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 1.6rem;
    height: 1.6rem;
    border-radius: 50%;
    background: var(--accent);
    color: var(--bg);
    font-size: 0.8rem;
    font-weight: 700;
    flex-shrink: 0;
  }

  h3 {
    font-size: 1.05rem;
    margin: 1.5rem 0 0.5rem;
    color: var(--purple);
  }

  p, li { color: var(--text); margin-bottom: 0.6rem; }
  ul { padding-left: 1.5rem; margin-bottom: 1rem; }

  .ring-visual {
    background: var(--ring-bg);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 2rem;
    margin: 1.5rem 0;
    text-align: center;
  }

  .ring-svg { max-width: 380px; margin: 0 auto; display: block; }

  .ring-chain {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.15rem;
    flex-wrap: wrap;
    font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
    font-size: 1.05rem;
    margin-top: 1rem;
    color: var(--muted);
  }

  .ring-chain .letter {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 2rem;
    height: 2rem;
    border-radius: 6px;
    background: var(--surface);
    border: 1px solid var(--border);
    color: var(--text);
    font-weight: 600;
  }

  .ring-chain .arrow { color: var(--muted); font-size: 0.75rem; margin: 0 0.1rem; }

  .solution-box {
    background: var(--surface);
    border: 1px solid var(--green);
    border-left: 4px solid var(--green);
    border-radius: 8px;
    padding: 1.25rem 1.5rem;
    margin: 1.5rem 0;
  }

  .solution-box .label {
    color: var(--green);
    font-weight: 600;
    font-size: 0.85rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: 0.4rem;
  }

  .solution-box .words {
    font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
    font-size: 1.3rem;
    font-weight: 700;
    color: var(--text);
  }

  .solution-box .words .sep { color: var(--muted); font-weight: 400; margin: 0 0.5rem; }

  .callout {
    border-radius: 8px;
    padding: 1rem 1.25rem;
    margin: 1.25rem 0;
    font-size: 0.92rem;
  }

  .callout.info {
    background: rgba(88,166,255,0.08);
    border: 1px solid rgba(88,166,255,0.25);
  }

  .callout strong { color: var(--accent); }

  .tracking {
    width: 100%;
    border-collapse: collapse;
    margin: 1rem 0;
    font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
    font-size: 0.85rem;
  }

  .tracking th {
    text-align: left;
    padding: 0.5rem 0.75rem;
    border-bottom: 2px solid var(--border);
    color: var(--muted);
    font-weight: 600;
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .tracking td {
    padding: 0.4rem 0.75rem;
    border-bottom: 1px solid var(--border);
  }

  .tracking .ok { color: var(--green); }
  .tracking .blocked { color: var(--red); opacity: 0.6; }

  code {
    font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 0.15em 0.4em;
    font-size: 0.88em;
  }

  .arch {
    display: grid;
    grid-template-columns: 1fr auto 1fr auto 1fr;
    align-items: center;
    gap: 0.75rem;
    margin: 1.5rem 0;
    font-size: 0.88rem;
  }

  .arch-box {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 0.75rem 1rem;
    text-align: center;
  }

  .arch-box .title {
    font-weight: 700;
    color: var(--accent);
    font-size: 0.8rem;
    margin-bottom: 0.25rem;
  }

  .arch-arrow { color: var(--muted); font-size: 1.3rem; text-align: center; }

  .source-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: var(--surface);
    border: 1px solid var(--border);
    border-bottom: none;
    border-radius: 8px 8px 0 0;
    padding: 0.6rem 1rem;
    margin-top: 2.5rem;
  }

  .source-header .filename {
    font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
    font-size: 0.85rem;
    color: var(--text);
    font-weight: 600;
  }

  .source-header .meta { font-size: 0.78rem; color: var(--muted); }

  .source-code {
    background: var(--code-bg);
    border: 1px solid var(--border);
    border-radius: 0 0 8px 8px;
    overflow-x: auto;
    max-height: 80vh;
    overflow-y: auto;
  }

  .source-code pre {
    margin: 0;
    padding: 1rem;
    font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
    font-size: 0.8rem;
    line-height: 1.55;
    tab-size: 4;
    counter-reset: line;
  }

  .source-code .line {
    display: block;
    padding-left: 3.5rem;
    position: relative;
    min-height: 1.55em;
  }

  .source-code .line::before {
    counter-increment: line;
    content: counter(line);
    position: absolute;
    left: 0;
    width: 2.8rem;
    text-align: right;
    color: var(--muted);
    opacity: 0.4;
    font-size: 0.75rem;
    user-select: none;
  }

  .kw { color: #ff7b72; }
  .fn { color: #d2a8ff; }
  .st { color: #a5d6ff; }
  .cm { color: #8b949e; font-style: italic; }
  .nu { color: #79c0ff; }
  .bi { color: #ffa657; }
  .dc { color: #7ee787; }

  @media (max-width: 640px) {
    body { padding: 1rem; }
    h1 { font-size: 1.5rem; }
    .arch { grid-template-columns: 1fr; }
    .arch-arrow { transform: rotate(90deg); }
  }
</style>
</head>
<body>

<h1>Ring-Puzzle-Solver</h1>
<p class="subtitle">Ein Python-Script, das ein deutsches Buchstabenr&auml;tsel algorithmisch l&ouml;st &mdash; mit Backtracking, Ring-Constraints und Duden-Grundform-Filterung.</p>

<h2><span class="num">1</span> Das R&auml;tsel</h2>

<p>12 Buchstaben sind im Kreis angeordnet. Ziel: Finde eine Kette aus <strong>genau 2 W&ouml;rtern</strong>, die zusammen <em>alle</em> 12 Buchstaben mindestens einmal verwenden.</p>

<div class="ring-visual">
  <svg class="ring-svg" viewBox="0 0 300 300" xmlns="http://www.w3.org/2000/svg">
    <circle cx="150" cy="150" r="120" fill="none" stroke="#30363d" stroke-width="1.5" stroke-dasharray="6 4"/>
    <g font-family="SF Mono, Fira Code, Consolas, monospace" font-size="18" font-weight="700" fill="#e6edf3" text-anchor="middle" dominant-baseline="central">
      <!-- R (top, 0°) -->
      <circle cx="150" cy="30" r="20" fill="#1c2333" stroke="#58a6ff" stroke-width="1.5"/><text x="150" y="31">R</text>
      <!-- B (30°) -->
      <circle cx="210" cy="46" r="20" fill="#1c2333" stroke="#30363d" stroke-width="1.5"/><text x="210" y="47">B</text>
      <!-- E (60°) -->
      <circle cx="254" cy="96" r="20" fill="#1c2333" stroke="#30363d" stroke-width="1.5"/><text x="254" y="97">E</text>
      <!-- M (90°) -->
      <circle cx="270" cy="150" r="20" fill="#1c2333" stroke="#30363d" stroke-width="1.5"/><text x="270" y="151">M</text>
      <!-- P (120°) -->
      <circle cx="254" cy="204" r="20" fill="#1c2333" stroke="#30363d" stroke-width="1.5"/><text x="254" y="205">P</text>
      <!-- A (150°) -->
      <circle cx="210" cy="254" r="20" fill="#1c2333" stroke="#30363d" stroke-width="1.5"/><text x="210" y="255">A</text>
      <!-- L (180°) -->
      <circle cx="150" cy="270" r="20" fill="#1c2333" stroke="#30363d" stroke-width="1.5"/><text x="150" y="271">L</text>
      <!-- Z (210°) -->
      <circle cx="90" cy="254" r="20" fill="#1c2333" stroke="#30363d" stroke-width="1.5"/><text x="90" y="255">Z</text>
      <!-- I (240°) -->
      <circle cx="46" cy="204" r="20" fill="#1c2333" stroke="#30363d" stroke-width="1.5"/><text x="46" y="205">I</text>
      <!-- N (270°) -->
      <circle cx="30" cy="150" r="20" fill="#1c2333" stroke="#30363d" stroke-width="1.5"/><text x="30" y="151">N</text>
      <!-- H (300°) -->
      <circle cx="46" cy="96" r="20" fill="#1c2333" stroke="#30363d" stroke-width="1.5"/><text x="46" y="97">H</text>
      <!-- Y (330°) -->
      <circle cx="90" cy="46" r="20" fill="#1c2333" stroke="#30363d" stroke-width="1.5"/><text x="90" y="47">Y</text>
    </g>
  </svg>

  <div class="ring-chain">
    <span class="letter">R</span><span class="arrow">&rarr;</span>
    <span class="letter">B</span><span class="arrow">&rarr;</span>
    <span class="letter">E</span><span class="arrow">&rarr;</span>
    <span class="letter">M</span><span class="arrow">&rarr;</span>
    <span class="letter">P</span><span class="arrow">&rarr;</span>
    <span class="letter">A</span><span class="arrow">&rarr;</span>
    <span class="letter">L</span><span class="arrow">&rarr;</span>
    <span class="letter">Z</span><span class="arrow">&rarr;</span>
    <span class="letter">I</span><span class="arrow">&rarr;</span>
    <span class="letter">N</span><span class="arrow">&rarr;</span>
    <span class="letter">H</span><span class="arrow">&rarr;</span>
    <span class="letter">Y</span><span class="arrow">&rarr;</span>
    <span style="color:var(--muted);font-size:0.85rem;">(zur&uuml;ck zu R)</span>
  </div>
</div>

<h3>Regeln</h3>
<ul>
  <li><strong>Mindestens 4 Buchstaben</strong> pro Wort.</li>
  <li><strong>Sperr-Regel:</strong> Nachdem ein Buchstabe benutzt wurde, sind er selbst und seine beiden Ring-Nachbarn f&uuml;r den <em>n&auml;chsten</em> Buchstaben gesperrt.</li>
  <li><strong>Verkettung:</strong> Das n&auml;chste Wort beginnt mit dem letzten Buchstaben des vorherigen.</li>
  <li><strong>Nur Duden-Grundformen</strong> (inkl. Eigennamen). Keine Plurale, Deklinationen, Konjugationen.</li>
</ul>

<div class="callout info">
  <strong>Beispiel:</strong> Nach Benutzung von <code>Z</code> sind <code>L</code>, <code>Z</code>, <code>I</code> gesperrt &mdash; der n&auml;chste Buchstabe muss aus den &uuml;brigen 9 kommen.
</div>

<div class="solution-box">
  <div class="label">L&ouml;sung f&uuml;r diesen Ring</div>
  <div class="words">PRIMZAHL <span class="sep">&rarr;</span> LIBYEN</div>
</div>

<h2><span class="num">2</span> Wie das Script funktioniert</h2>

<div class="arch">
  <div class="arch-box">
    <div class="title">Wortliste</div>
    Eingebettet (~103) oder<br>externe Datei (1.9M)
  </div>
  <div class="arch-arrow">&rarr;</div>
  <div class="arch-box">
    <div class="title">Filter-Pipeline</div>
    Ring-Buchstaben &rarr;<br>Sperr-Regel &rarr; Grundform
  </div>
  <div class="arch-arrow">&rarr;</div>
  <div class="arch-box">
    <div class="title">Backtracking-Solver</div>
    Greedy + Pruning<br>nach Abdeckung
  </div>
</div>

<h3>Schritt 1: Wortliste laden</h3>
<p>Das Script bringt ~103 handkuratierte Duden-Grundformen mit (Nomen, Verben im Infinitiv, Adjektive, Eigennamen). Alternativ kann eine externe Wortliste &uuml;bergeben werden &mdash; dann greift automatisch ein Beugungsform-Filter.</p>

<h3>Schritt 2: Ring-Filterung</h3>
<p>Aus der Wortliste bleiben nur W&ouml;rter &uuml;brig, die:</p>
<ul>
  <li>ausschliesslich Ring-Buchstaben enthalten,</li>
  <li>mindestens 4 Buchstaben lang sind,</li>
  <li>die Sperr-Regel erf&uuml;llen (kein Buchstabe folgt auf sich selbst oder seine Nachbarn).</li>
</ul>

<h3>Schritt 3: Beugungsform-Heuristik</h3>
<p>Bei externen Listen erkennt <code>is_likely_base_form()</code> typische Muster und entfernt sie:</p>
<ul>
  <li>Adjektiv-Deklinationen: <code>HEILBARE</code> &rarr; <code>HEILBAR</code> existiert &rarr; raus</li>
  <li>1. Person / Imperativ: <code>PRAHLE</code> &rarr; <code>PRAHLEN</code> existiert &rarr; raus</li>
  <li>Partizip-Formen: <code>ZERMAHLENE</code> &rarr; <code>ZERMAHLEN</code> existiert &rarr; raus</li>
</ul>

<h3>Schritt 4: Backtracking-Solver</h3>
<p>Der Solver probiert systematisch Wortketten durch:</p>
<ul>
  <li><strong>Greedy-Sortierung:</strong> W&ouml;rter mit h&ouml;herer Buchstaben-Abdeckung werden zuerst probiert.</li>
  <li><strong>Pruning:</strong> Ein Wort wird nur angeh&auml;ngt, wenn es mindestens einen neuen Buchstaben bringt.</li>
  <li><strong>Fr&uuml;habbruch:</strong> Nach 5 perfekten L&ouml;sungen (12/12) stoppt die Suche.</li>
</ul>

<h2><span class="num">3</span> Die L&ouml;sung Schritt f&uuml;r Schritt</h2>

<p><strong>Wort 1: PRIMZAHL</strong> &mdash; deckt 8 von 12 Buchstaben ab.</p>
<table class="tracking">
  <thead>
    <tr><th>#</th><th>Buchstabe</th><th>Sperrt danach</th><th>N&auml;chster</th><th></th></tr>
  </thead>
  <tbody>
    <tr><td>1</td><td>P</td><td class="blocked">A, M, P</td><td class="ok">R</td><td class="ok">&#10003;</td></tr>
    <tr><td>2</td><td>R</td><td class="blocked">B, R, Y</td><td class="ok">I</td><td class="ok">&#10003;</td></tr>
    <tr><td>3</td><td>I</td><td class="blocked">I, N, Z</td><td class="ok">M</td><td class="ok">&#10003;</td></tr>
    <tr><td>4</td><td>M</td><td class="blocked">E, M, P</td><td class="ok">Z</td><td class="ok">&#10003;</td></tr>
    <tr><td>5</td><td>Z</td><td class="blocked">I, L, Z</td><td class="ok">A</td><td class="ok">&#10003;</td></tr>
    <tr><td>6</td><td>A</td><td class="blocked">A, L, P</td><td class="ok">H</td><td class="ok">&#10003;</td></tr>
    <tr><td>7</td><td>H</td><td class="blocked">H, N, Y</td><td class="ok">L</td><td class="ok">&#10003;</td></tr>
    <tr><td>8</td><td>L</td><td class="blocked">A, L, Z</td><td>&mdash;</td><td></td></tr>
  </tbody>
</table>

<p style="color:var(--muted);">PRIMZAHL endet mit <strong>L</strong> &rarr; n&auml;chstes Wort muss mit L beginnen.</p>

<p><strong>Wort 2: LIBYEN</strong> &mdash; deckt die fehlenden 4 Buchstaben ab (B, E, N, Y).</p>
<table class="tracking">
  <thead>
    <tr><th>#</th><th>Buchstabe</th><th>Sperrt danach</th><th>N&auml;chster</th><th></th></tr>
  </thead>
  <tbody>
    <tr><td>1</td><td>L</td><td class="blocked">A, L, Z</td><td class="ok">I</td><td class="ok">&#10003;</td></tr>
    <tr><td>2</td><td>I</td><td class="blocked">I, N, Z</td><td class="ok">B</td><td class="ok">&#10003;</td></tr>
    <tr><td>3</td><td>B</td><td class="blocked">B, E, R</td><td class="ok">Y</td><td class="ok">&#10003;</td></tr>
    <tr><td>4</td><td>Y</td><td class="blocked">H, R, Y</td><td class="ok">E</td><td class="ok">&#10003;</td></tr>
    <tr><td>5</td><td>E</td><td class="blocked">B, E, M</td><td class="ok">N</td><td class="ok">&#10003;</td></tr>
    <tr><td>6</td><td>N</td><td class="blocked">H, I, N</td><td>&mdash;</td><td></td></tr>
  </tbody>
</table>

<div class="solution-box">
  <div class="label">Ergebnis: 12 / 12 Buchstaben abgedeckt</div>
  <div class="words">
    <span style="color:var(--purple)">P R I M Z A H L</span>
    <span class="sep">+</span>
    <span style="color:var(--accent)">L I B Y E N</span>
    <span class="sep">=</span>
    <span style="color:var(--green)">{R,B,E,M,P,A,L,Z,I,N,H,Y}</span>
  </div>
</div>

<h2><span class="num">4</span> Benutzung</h2>

<div style="background:var(--surface);border:1px solid var(--border);border-radius:8px;padding:1rem 1.25rem;margin:1rem 0;font-family:'SF Mono','Fira Code','Consolas',monospace;font-size:0.85rem;line-height:1.8;overflow-x:auto;">
<span class="cm"># Standard: eingebettete Liste, max. 2 W&ouml;rter</span><br>
python3 ring_puzzle_solver.py<br><br>
<span class="cm"># Bestimmte W&ouml;rter pr&uuml;fen</span><br>
python3 ring_puzzle_solver.py --check PRIMZAHL LIBYEN<br><br>
<span class="cm"># Externe Wortliste (1.9M W&ouml;rter), Filter aktiv</span><br>
python3 ring_puzzle_solver.py --wordlist german_words.txt<br><br>
<span class="cm"># Filter deaktivieren (auch Beugungsformen erlaubt)</span><br>
python3 ring_puzzle_solver.py --wordlist german_words.txt --no-filter<br><br>
<span class="cm"># Mehr W&ouml;rter erlauben + Debug-Ausgabe</span><br>
python3 ring_puzzle_solver.py --max-words 4 --verbose
</div>

<h2><span class="num">5</span> Quellcode</h2>

<div class="source-header">
  <span class="filename">ring_puzzle_solver.py</span>
  <span class="meta">Python 3 &middot; 542 Zeilen &middot; keine Dependencies</span>
</div>
<div class="source-code"><pre id="source-pre"></pre></div>

<script>
const source = `#!/usr/bin/env python3
"""
Ring-Buchstabenr\u00e4tsel-Solver
=============================
12 Buchstaben im Kreis angeordnet. Bilde eine Kette von W\u00f6rtern (mind. 4 Buchstaben),
wobei:
- Nach Benutzung eines Buchstabens: er selbst + seine Nachbarn im Ring sind f\u00fcr den
  N\u00c4CHSTEN Schritt gesperrt
- N\u00e4chstes Wort beginnt mit dem Endbuchstaben des vorherigen
- Ziel: alle 12 Buchstaben mindestens einmal verwenden (stets mit 2 W\u00f6rtern m\u00f6glich)

Spielregeln (Original):
- Erlaubt: Duden-Stichw\u00f6rter als Grundform (inkl. Eigennamen, Abk\u00fcrzungen)
- NICHT erlaubt: Beugungsformen (Plurale, Deklinationen, Konjugationen, Imperative)
- Beispiele: PRIMZAHL \u2705, PRIMZAHLEN \u274c (Plural), HEILBARE \u274c (dekliniert)

Verwendung:
    python ring_puzzle_solver.py                      # Standardr\u00e4tsel l\u00f6sen (max. 2 W\u00f6rter)
    python ring_puzzle_solver.py --wordlist pfad.txt  # Eigene Wortliste (mit Beugungsform-Filter)
    python ring_puzzle_solver.py --max-words 3        # Max. W\u00f6rter in Kette
    python ring_puzzle_solver.py --no-filter           # Beugungsform-Filter deaktivieren
    python ring_puzzle_solver.py --verbose             # Schritt-f\u00fcr-Schritt-Ausgabe
"""

import argparse
import sys
import os
from itertools import product as iter_product
from typing import Optional

# ============================================================
# RING-KONFIGURATION
# ============================================================
# Buchstaben im Kreis: R \u2192 B \u2192 E \u2192 M \u2192 P \u2192 A \u2192 L \u2192 Z \u2192 I \u2192 N \u2192 H \u2192 Y \u2192 (zur\u00fcck zu R)
RING = ['R', 'B', 'E', 'M', 'P', 'A', 'L', 'Z', 'I', 'N', 'H', 'Y']

def build_neighbors(ring: list[str]) -> dict[str, set[str]]:
    """Erstellt Nachbarschafts-Map f\u00fcr den Ring."""
    n = len(ring)
    neighbors = {}
    for i, ch in enumerate(ring):
        left = ring[(i - 1) % n]
        right = ring[(i + 1) % n]
        neighbors[ch] = {left, ch, right}
    return neighbors

NEIGHBORS = build_neighbors(RING)
RING_SET = set(RING)

# ============================================================
# WORT-VALIDIERUNG IM RING
# ============================================================

def is_valid_word_in_ring(word: str) -> bool:
    """
    Pr\u00fcft, ob ein Wort unter der Ring-Sperr-Regel gebildet werden kann.
    Regel: Nach Benutzung von Buchstabe X sind X und seine Ring-Nachbarn
    f\u00fcr den N\u00c4CHSTEN Buchstaben gesperrt.
    """
    word = word.upper()
    if not all(ch in RING_SET for ch in word):
        return False
    for i in range(len(word) - 1):
        current = word[i]
        next_ch = word[i + 1]
        blocked = NEIGHBORS[current]
        if next_ch in blocked:
            return False
    return True

def get_tracking_table(word: str) -> list[dict]:
    """Erzeugt das Tracking-Schema f\u00fcr ein Wort."""
    word = word.upper()
    table = []
    for i, ch in enumerate(word):
        blocked = NEIGHBORS[ch]
        available = RING_SET - blocked
        table.append({
            'schritt': i + 1,
            'buchstabe': ch,
            'gesperrt': sorted(blocked),
            'verfuegbar': sorted(available),
            'naechster': word[i + 1] if i + 1 < len(word) else '-'
        })
    return table

# ============================================================
# WORTLISTE
# ============================================================

# Eingebettete Liste: ~103 Duden-Stichw\u00f6rter (Grundformen)
# NUR: Nomen (Singular), Adjektive (undekliniert), Verben (Infinitiv),
# Adverbien, Eigennamen. KEINE Beugungsformen.
EMBEDDED_WORDS = [
    # --- Nomen (Singular) ---
    "AHLE", "BIER", "BLEI", "EHRE", "EILE", "ERLE",
    "HARN", "HARZ", "HEIM", "HELM", "HERZ", "HIRN",
    "LEIB", "LEIM", "LENZ", "LIRA", "MAHL", "NERZ",
    "PIER", "REIM", "ZAHL",
    "BAHRE", "BIRNE", "ENZYM", "LEHRE", "LEIER", "LEIHE",
    "LEPRA", "LIANE", "MIENE", "MIEZE", "PERLE", "PRAHM",
    "PRIEL", "REIHE", "ZEILE",
    "ARZNEI", "RANZEN",
    "ANLEIHE", "PRIMZAHL",
    # --- Adjektive (Grundform, undekliniert) ---
    "HEHR", "NAHE", "PRIM", "ZAHM",
    "NAHBAR", "HEILBAR", "LERNBAR", "ZAHLBAR", "PEILBAR",
    "PERIPHER", "BLEIERN", "HERZNAH",
    "ABNEHMBAR", "ERLERNBAR", "ABZAHLBAR", "ANZAHLBAR",
    # --- Verben (Infinitiv) ---
    "HEILEN", "LEHREN", "LEIERN", "LEIHEN", "MAHLEN",
    "PEILEN", "PRAHLEN", "ZAHLEN", "ZEHREN", "ZEIHEN",
    "HARZEN", "LENZEN", "LERNEN", "PIEPEN", "REIHEN",
    "EPILIEREN", "ARMIEREN",
    "ABHEILEN", "ABLEIERN", "ABLERNEN", "ABPERLEN",
    "ABZAHLEN", "ABZEHREN",
    "ANLEIERN", "ANLERNEN", "ANMAILEN", "ANPEILEN",
    "ANRANZEN", "ANREIHEN", "ANZAHLEN",
    "ERLERNEN", "HERLEIERN", "HERLEIHEN",
    "HERANEILEN", "REPRIMIEREN", "ZERMAHLEN", "HEIMZAHLEN",
    # --- Adverbien ---
    "HERAB", "HERAN", "HIER", "HIERAN", "HIERHER",
    # --- Eigennamen (Duden-Stichw\u00f6rter) ---
    "IRAN", "LIMA", "BIRMA", "LIBYEN", "BAYERN", "RHEIN",
]

def is_likely_base_form(word: str, all_words: set[str]) -> bool:
    """
    Heuristik: Ist das Wort wahrscheinlich eine Grundform (Duden-Stichwort)?
    Filtert typische deutsche Beugungsformen heraus.
    """
    w = word.upper()

    # Adjektiv-Deklinationen: -bare/-baren/-barer/-bares von -bar
    for suffix, base_suffix in [("BARE", "BAR"), ("BAREN", "BAR"), ("BARER", "BAR"),
                                 ("BARES", "BAR"), ("BAREM", "BAR")]:
        if w.endswith(suffix) and w[:-len(suffix)] + base_suffix in all_words:
            return False

    # Adjektiv-Deklinationen: Komparativ, -ern, -nah Endungen
    for suffix in ["ERE", "EREN", "ERER", "EREM", "ERES",
                    "ERNE", "ERNEN", "ERNER", "ERNEM",
                    "NAHE", "NAHEN", "NAHER", "NAHEM"]:
        if w.endswith(suffix):
            for base_len in [len(suffix) - 1, len(suffix) - 2]:
                if base_len > 0 and w[:-base_len] in all_words:
                    return False

    # 1. Person / Imperativ: -E wenn Infinitiv auf -EN existiert
    if w.endswith("E") and len(w) > 4:
        infinitiv = w[:-1] + "EN"
        if infinitiv in all_words and infinitiv != w:
            return False

    # Partizip-artige Formen: ZERMAHLENE etc.
    for suffix in ["ENE", "ENEN", "ENER", "ENEM"]:
        if w.endswith(suffix) and w[:-len(suffix)] + "EN" in all_words:
            return False

    return True


def load_wordlist(filepath=None, apply_filter=True):
    """
    L\u00e4dt Wortliste aus Datei oder nutzt eingebettete Liste.
    Filtert auf: nur Ring-Buchstaben, mind. 4 Zeichen, Ring-Regel g\u00fcltig.
    """
    raw_words = set()
    from_external = False

    if filepath and os.path.exists(filepath):
        print(f"Lade Wortliste aus: {filepath}")
        with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
            for line in f:
                word = line.strip().split()[0] if line.strip() else ""
                word = word.strip('.,;:!\\"\\'\\'()[]{}')
                if word:
                    raw_words.add(word.upper())
        print(f"   {len(raw_words)} Rohw\u00f6rter geladen")
        from_external = True
    else:
        if filepath:
            print(f"Datei nicht gefunden: {filepath}")
        print("Verwende eingebettete Wortliste (nur Grundformen)")
        raw_words = {w.upper() for w in EMBEDDED_WORDS}

    valid = set()
    for word in raw_words:
        if len(word) < 4:
            continue
        if not all(ch in RING_SET for ch in word):
            continue
        if is_valid_word_in_ring(word):
            valid.add(word)

    print(f"   {len(valid)} W\u00f6rter nach Ring-Filterung")

    if from_external and apply_filter:
        before = len(valid)
        valid = {w for w in valid if is_likely_base_form(w, valid)}
        removed = before - len(valid)
        if removed > 0:
            print(f"   Beugungsform-Filter: {removed} Formen entfernt")

    print(f"{len(valid)} g\u00fcltige W\u00f6rter")
    return valid

# ============================================================
# SOLVER
# ============================================================

def letters_used(word: str) -> set[str]:
    return set(word.upper()) & RING_SET

def chain_coverage(chain: list[str]) -> set[str]:
    covered = set()
    for w in chain:
        covered |= letters_used(w)
    return covered

def solve(wordlist, max_words=2, verbose=False):
    """
    Findet Wortketten, die m\u00f6glichst alle 12 Buchstaben abdecken.
    Strategie: Backtracking mit Greedy-Sortierung und Pruning.
    """
    by_start = {}
    for w in wordlist:
        by_start.setdefault(w[0], []).append(w)

    for key in by_start:
        by_start[key].sort(key=lambda w: len(letters_used(w)), reverse=True)

    best_solutions = []
    best_coverage = 0

    def backtrack(chain, covered, depth):
        nonlocal best_solutions, best_coverage

        coverage = len(covered)

        if coverage > best_coverage:
            best_coverage = coverage
            best_solutions = [list(chain)]
            if verbose:
                print(f"  Neue beste Abdeckung: {coverage}/12 — {' -> '.join(chain)}")
        elif coverage == best_coverage:
            best_solutions.append(list(chain))

        if coverage == 12:
            return

        if depth >= max_words:
            return

        if chain:
            next_start = chain[-1][-1]
        else:
            for start_letter in RING:
                if start_letter not in by_start:
                    continue
                for word in by_start[start_letter]:
                    new_covered = covered | letters_used(word)
                    chain.append(word)
                    backtrack(chain, new_covered, depth + 1)
                    chain.pop()
                    if best_coverage == 12 and len(best_solutions) >= 5:
                        return
            return

        next_start = chain[-1][-1]
        if next_start not in by_start:
            return

        for word in by_start[next_start]:
            new_letters = letters_used(word) - covered
            if not new_letters and coverage < 12:
                continue

            new_covered = covered | letters_used(word)
            chain.append(word)
            backtrack(chain, new_covered, depth + 1)
            chain.pop()

            if best_coverage == 12 and len(best_solutions) >= 5:
                return

    print(f"\\nSuche Wortketten (max. {max_words} W\u00f6rter)...")
    backtrack([], set(), 0)
    return best_solutions

# ============================================================
# MAIN
# ============================================================

def main():
    parser = argparse.ArgumentParser(description="Ring-Puzzle-Solver")
    parser.add_argument('--wordlist', '-w', type=str, default=None)
    parser.add_argument('--max-words', '-m', type=int, default=2)
    parser.add_argument('--no-filter', action='store_true')
    parser.add_argument('--verbose', '-v', action='store_true')
    parser.add_argument('--check', '-c', type=str, nargs='+')
    parser.add_argument('--track', '-t', type=str)
    parser.add_argument('--prompt', '-p', action='store_true')

    args = parser.parse_args()
    # ... (Ausgabe + Solver-Logik)

if __name__ == '__main__':
    main()`;

function highlight(code) {
  const keywords = ['def', 'class', 'if', 'elif', 'else', 'for', 'while', 'return',
    'import', 'from', 'as', 'with', 'try', 'except', 'finally', 'raise', 'yield',
    'lambda', 'and', 'or', 'not', 'in', 'is', 'True', 'False', 'None', 'pass',
    'break', 'continue', 'nonlocal', 'global', 'assert', 'del'];
  const builtins = ['print', 'len', 'set', 'dict', 'list', 'str', 'int', 'range',
    'sorted', 'all', 'any', 'enumerate', 'open', 'type', 'Optional'];

  return code.split('\n').map(rawLine => {
    let line = rawLine
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');

    line = line.replace(/("""[\s\S]*?"""|'''[\s\S]*?'''|"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*'|f"(?:[^"\\]|\\.)*"|f'(?:[^'\\]|\\.)*')/g,
      '<span class="st">$1</span>');

    line = line.replace(/(#.*)$/g, '<span class="cm">$1</span>');
    line = line.replace(/\b(\d+\.?\d*)\b/g, '<span class="nu">$1</span>');

    const kwRe = new RegExp('\\b(' + keywords.join('|') + ')\\b', 'g');
    line = line.replace(kwRe, (m) => '<span class="kw">' + m + '</span>');

    const biRe = new RegExp('\\b(' + builtins.join('|') + ')\\b', 'g');
    line = line.replace(biRe, '<span class="bi">$1</span>');

    line = line.replace(/(<span class="kw">def<\/span>\s+)(\w+)/g, '$1<span class="fn">$2</span>');

    return '<span class="line">' + line + '</span>';
  }).join('\n');
}

document.getElementById('source-pre').innerHTML = highlight(source);
</script>

</body>
</html>
